import os
import numpy as np
import torch
import matplotlib.pyplot as plt
import pandas as pd

# 核心子圖包含整個節點
# 處理PyG支援的可解釋方法

class ExplainerEdgeSelector:
    """
    Select important edges using explanations generated by an explainer model.
    """

    def __init__(self, base_dir, explainer_name, dataset_name, node_choose, top_k_percent, device="cpu"):
        """
        :param base_dir: The base directory where experiment results are stored.
        :param explainer_name: Name of the explainer model (e.g., 'GNNExplainer').
        :param dataset_name: Name of the dataset (e.g., 'CiteSeer').
        :param node_choose: The name of the experiment folder under the dataset (default: 'random').
        :param top_k_percent: The percentage of top important edges to select.
        """

        self.base_path = os.path.join(base_dir, explainer_name, dataset_name)
        self.sub_dirs = sorted([d for d in os.listdir(self.base_path) if d.endswith("GCN2Classifier")]) # GCN2Regressor
        self.edge_masks = []  # 存放所有 edge_mask
        self.edge_aggregated = None  # 平均 edge_mask
        self.top_k_percent = top_k_percent
        self.device = device
        self.node_choose = node_choose

    def load_data(self):
        """
        根據每個 model 的 node_record.csv 中某欄位的 one-hot 選擇節點，
        並從 share_nodes/ 中載入 edge_mask 後加總。
        """
        self.edge_masks = []
        self.node_count = 0

        for sub_dir in self.sub_dirs:  # ex: '1_GCN2Classifier'
            model_dir = os.path.join(self.base_path, sub_dir)
            share_node_dir = os.path.join(model_dir, "share_nodes")
            csv_path = os.path.join(model_dir, "node_record.csv")

            if not os.path.exists(csv_path):
                print(f"Warning: node_record.csv not found in {model_dir}")
                continue

            df = pd.read_csv(csv_path)
            if self.node_choose not in df.columns:
                print(f"Warning: column '{self.node_choose}' not found in {csv_path}")
                continue

            selected_nodes = df[df[self.node_choose] == 1]["Node"].tolist()

            # 設定 node 數量（僅需計算一次）
            if self.node_count == 0:
                self.node_count = len(selected_nodes) 

            for node_id in selected_nodes:
                file_path = os.path.join(share_node_dir, f"node_{node_id}.npz")
                if not os.path.exists(file_path):
                    print(f"File {file_path} does not exist. Warn!!!!.")
                    continue

                data = np.load(file_path, allow_pickle=True)
                edge_mask = data.get("edge_mask", None)

                if edge_mask is not None:
                    self.edge_masks.append(edge_mask)

        if self.edge_masks:
            # 將同一解釋子圖內不同node的重要度相加，並把不同模型的解釋子圖的重要度也相加
            self.edge_aggregated = np.sum(self.edge_masks, axis=0) 
            print(f"Number of nodes selected: {self.node_count}")
            print(f"Number of edges picked in the subgraph: {np.count_nonzero(self.edge_aggregated)}")


    def select_edges(self):
        """
        Selects the top-k% most important edges and returns them as a PyTorch Tensor.

        :return: Tensor of selected edge indices.
        """
        if self.edge_aggregated is None:
            raise ValueError("No edge importance data available. Run load_data() first.")

        k = int(len(self.edge_aggregated) * self.top_k_percent)
        top_k_edges = np.argsort(self.edge_aggregated)[-k:]  # 取前 K% 的邊

        # 轉換為 PyTorch Tensor，並放到對應的 device
        return torch.tensor(top_k_edges, dtype=torch.long, device=self.device)
        

    def plot_edge_distribution(self):
        """
        Plots and saves the distribution of edge importance scores.
        """
        if self.edge_aggregated is None:
            raise ValueError("No edge values available. Run load_data() first.")

        save_path = os.path.join(self.base_path, "edge_importance_distribution.png")

        plt.figure(figsize=(8, 6))
        plt.hist(self.edge_aggregated, bins=50, color="blue", alpha=0.7, edgecolor="black")
        plt.xlabel("Edge Importance Score")
        plt.ylabel("Frequency")
        plt.title("Edge Importance Score Distribution")
        plt.grid(True)

        plt.savefig(save_path)
        print(f"Edge importance distribution saved to {save_path}")

    def get_node_count(self):
        return self.node_count

    def get_edge_count(self):
        return np.count_nonzero(self.edge_aggregated)