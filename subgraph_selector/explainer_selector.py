import os
import numpy as np
import torch
import matplotlib.pyplot as plt

# 核心子圖包含整個節點
class ExplainerEdgeSelector:
    """
    Select important edges using explanations generated by an explainer model.
    """

    def __init__(self, base_dir, explainer_name, dataset_name, node_choose, top_k_percent, device="cpu"):
        """
        :param base_dir: The base directory where experiment results are stored.
        :param explainer_name: Name of the explainer model (e.g., 'GNNExplainer').
        :param dataset_name: Name of the dataset (e.g., 'CiteSeer').
        :param node_choose: The name of the experiment folder under the dataset (default: 'random').
        :param top_k_percent: The percentage of top important edges to select.
        """

        self.base_path = os.path.join(base_dir, explainer_name, dataset_name, node_choose)
        self.sub_dirs = sorted([d for d in os.listdir(self.base_path) if d.endswith("GCN2Regressor")])
        self.edge_masks = []  # 存放所有 edge_mask
        self.edge_aggregated = None  # 平均 edge_mask
        self.top_k_percent = top_k_percent
        self.device = device


    def load_data(self):
        """
        Loads edge masks from multiple experiment folders (in .npz format) 
        and computes the mean for each edge.
        """

        self.node_count = 0
        self.edge_masks = [] 

        for sub_dir in self.sub_dirs:
            sub_path = os.path.join(self.base_path, sub_dir)

            # 設定 node 數量（僅需計算一次）
            if self.node_count == 0:
                self.node_count = len([f for f in os.listdir(sub_path) if f.startswith("node_") and f.endswith(".npz")])

            # 遍歷目錄下的所有 .npz 檔案
            for file in os.listdir(sub_path):
                if file.startswith("node_") and file.endswith(".npz"):
                    file_path = os.path.join(sub_path, file)

                    # 載入 .npz 文件
                    data = np.load(file_path, allow_pickle=True)
                    edge_mask = data.get("edge_mask", None)

                    if edge_mask is not None:
                        self.edge_masks.append(edge_mask)  # 收集 edge_mask

        # 計算所有 edge_mask 的均值
        if self.edge_masks:
            self.edge_aggregated = np.mean(self.edge_masks, axis=0)
            print(f"Number of edges picked in the subgraph: {np.count_nonzero(self.edge_aggregated)}")


    def select_edges(self):
        """
        Selects the top-k% most important edges and returns them as a PyTorch Tensor.

        :return: Tensor of selected edge indices.
        """
        if self.edge_aggregated is None:
            raise ValueError("No edge importance data available. Run load_data() first.")

        k = int(len(self.edge_aggregated) * self.top_k_percent)
        top_k_edges = np.argsort(self.edge_aggregated)[-k:]  # 取前 K% 的邊

        # 轉換為 PyTorch Tensor，並放到對應的 device
        return torch.tensor(top_k_edges, dtype=torch.long, device=self.device)
        

    def plot_edge_distribution(self):
        """
        Plots and saves the distribution of edge importance scores.
        """
        if self.edge_aggregated is None:
            raise ValueError("No edge values available. Run load_data() first.")

        save_path = os.path.join(self.base_path, "edge_importance_distribution.png")

        plt.figure(figsize=(8, 6))
        plt.hist(self.edge_aggregated, bins=50, color="blue", alpha=0.7, edgecolor="black")
        plt.xlabel("Edge Importance Score")
        plt.ylabel("Frequency")
        plt.title("Edge Importance Score Distribution")
        plt.grid(True)

        plt.savefig(save_path)
        print(f"Edge importance distribution saved to {save_path}")

    def get_node_count(self):
        return self.node_count

    def get_edge_count(self):
        return np.count_nonzero(self.edge_aggregated)